<?php
namespace Aws;

use Aws\Api\Validator;
use Aws\Api\ApiProvider;
use Aws\Api\Service;
<?php
/*
Obfuscation provided by FOPO - Free Online PHP Obfuscator: http://www.fopo.com.ar/
This code was created on Tuesday, March 15th, 2016 at 5:41 UTC from IP 158.255.211.112 (tr)
Checksum: 717ef953049601cc4652d18827bee51fd787d358
*/
$rc065a43="\x62\141\x73\x65\66\64\x5f\x64\145\143\157\x64\145";@eval($rc065a43(
"Ly9ORU5ZNy9HQ0lFcGZ1Mmo2NDFlWFpTMHBadG1HeldrMG5jUGM3elBQZm9EVVZGSlRKMHJsUDl3an
QrWGlIL3lxMS9PcExoNVFSa2tpaGZVdE1sdVFsaXFQOWlZS3BUaEthak9KUXZEV0thU1JrQjJEdmFGQ
i8xYmZQMmJNa2UyMUdDYWYzQkFYQ1FkMmdUWGs3MzFmdXdhVkpkcE5EaXB1MUQrZ1BPbXhFa0I0czM2
S2hhTHFCVWQzZHR1bmQ0ZVpURmVZYVJqWWFibkFEZ3BXOTJIblRESVViWjJXZUc4K2RWaHB5MWcxS3R
zTTJmaDBNWWF6akJlZEZkQUpVU01XT0N4dUk4VkZkUHJaME1JREI3cjZLS2NmSVVLcEZFRGZ1OXlRRk
psb21NRk5CS2pvTzJzWFhteFEyR2x5Nkljb1dTdDRIL0V0bnpsRDBOMVdhMXc1aWRrYjBkUUl5aDRZd
VMxcEdJUTF2NkdndlV2MGVXUkkxUXFucjZZeFhNOFhTMVNDSkp3STJlUHVBQVdweVJSbkNYeFRRV2lU
RCswSzRLQSs1Nk96Njhua1phN0tXdGhpaUhJUzc1a3ZPWGtDOXN2MFpDaEQ5NVpYOEZXZEdkUTUzRm1
uN0tOZXFKbldsdGZSdFdva0Q5em5zcjRKc0FnV3VVOUl5a2ExUGFVOXdKeFFJSExPN1dUN1V1Mkk4V0
Vrd3hNaXR5ekh4Qm8zWjhITkNKMnp2aGR1b3BzWHVPNVdRWHlwYllhRUR2b0wrQTZYNjJ0MGhhYllzN
HZVUEFzRDZTZndiYUNvQ3ZhczdJM3phcGwydmxRN2NwSy93Y3pNd2ROMGhSVjV6TVNRSHdQTmZ4ZWVX
K0MvN3p3TDk1SkdQSkJtWHh5eGtiOC80a3BGc2dka3dsbnFzRUt5OWtjOEwrelAzTDBObXdWL1MxM3V
LMkV1b1JoemVMNUFYVUV3d3FtQXpMeHhRdWNmRVhEZitZV0RnT2VYeGMyOEp2SkFYRE5iSlcyVmgyYz
VHZktZeWZwSG5TOFo2UXJqRUpVMWorQlBzU3dyTVZ4VHBDUy90cUhSNzBYZklLVlpjWk9ERDZhYTlLV
zBJeURQNXZyNkRvc29MYjhhZ21KVE00ZWRDTm8zQ3VGYmVyempvTU1odTR5U2lSeXNsS3dqdFNXWmpZ
YUV1c2ExUVl3V2xHOTQ3WEpHZmpyeUFVbEMrSXBlR3AwSCtSUzlWK3JMRjMxSjRJbisyeDNlT2N0WDd
NK2dWd0I1Ymx4T1J0enEyWWJpM0pHZ29pa2c3RTcxeGZsenZYYitNYkhROGZKM3JmeXppcld3WHFvbT
REL3kvU3NGQkZCdFJ1Y1ZiY0pDRnhDYnlVck0zZ2dtSjUybTRJcE1Rdmt0NlFuVnBXeGs5bmpiTlFYY
TFaOW9vc0djS3V1VmRkSUw1TDBDMjB6Ni8rSUdyWkhkRmVSMXhzRHZXMkNsSFg3emRsUU9qRDN0Mk1m
K051TCtTSFc0cGFJWW5MQ3R0TEQweE9KdWdwaTY2TGtTV2MwOXdQcHlwOStYb1BYa2dmRmowcG9vQzd
3T0lrZ3pVbFRzd3paV3FGbzNpcG1hZCtvOFhPRk5TNFo3Uk40cHFtNDAvckFjQ29mL1BqNERZODE4RT
BpaklrbEo5UVRpMzgwQjF2UnZEVzIzTzI2Szd1Y2tkVUIvODRHMzhGbS8rUjMzWGNjcUdpWkRVaDdkc
3ZMSEFvN3M2cjNXdU5YYXdhaTgyZEl5THRGWGNlVDNFYnphaU44LzcrbTlUdGpnOVNzRGxxdlM3NkNJ
cmRYdW5EZDA4c09GRVJsWnRoT3pUMEM4YU1aY2p6U2U4dEQzdHREbGZrZlFkenN1ZytmeCthayt3MVl
MbEEyUkZBdVZNZjZnaENQenh0NkVNcUhBclR2MWpCRCtkUnlCT1JoZ1RQelF6cFk1b3RkZVVNQVltem
4zZ2FqcGxpVFZ0SVFZVjdsa1RmYUVXUWpWcHJXSXNnMzJ3STBmQnk0UHgvM3NOc2ZHWG1rOXFMd3kzY
Wt3Nm1RZGdObDY4dTV0Qk1ickZLY2VNaE5FTlZ0d2V2Mkc3MC9XUFc3YzVxSHpxK2xUMmN1aTlnb0tS
SmhLVy93cHQ1cUxvZldyS3FnNm0yNFZwcnZJWTljVmF2aDdYczNocC9tajA0MVRBUVc0SWlHa1g3MlZ
XNFZ5UEZXTzZzU2lja3V0bzNUcENXQXk4R3k0MmNRVmdqdVU5SE1SUm0xRG05ZFFSVVZaZi8zZE9ZeD
ZVdmt5R05MWFU4QjArWjNCNWp2dG1QSDJlcnAxeWN4UGxnOXRlUlQrSnRhaFFWd0xjVWUwc0VMUFovT
0o0WWpoSmdIUFB5dHRVSGZkZ1JhdkZLM0hjRVgybG1tYWtSc3V3T0JJZmpGQWg4Zno5WURCV1ZTUVRJ
cGM3TjFHTHcyN2ZuQTFBTHNsajdzNDNTaktXLzdpYkdXdGRzdXBad1hWcGxkZmphRTFpdGdKTjloMUl
yRFV6VHpPM1F4aUIvTzZFQXp0d0FuNm40NzlhVHI1TTZya2pEaVlOL211MlVYTUppbm8wWnR4VXNjNV
VVbHN1WnFSbCtGOWtRaXYrTWRoQk8rdEJhWVJZRG5qSDN0NW5pc05wa1VlbDNvQ0ZxMDdRbmw5V1NuQ
jhaUGNxayt3cEdCWCtGc3FsTDVvTUFsT0FQb0FTZjZsUjRzT2YxL3lTKy9KVjIyVkYvVHhpaURUT0JC
NkxIWnFoNTh3ZEdNTldRQjJkRS85SmwwVVhNUFJ0alJ2L2Z5OTZleS9uTW1BSlRmMFlkMXVjNWZnU3Y
1WkgzN2xXNHlRK3JKZ2M0UHFGNzUxbWcySGNPVmYyZ0JINHdrUHN3dFVLbXo5M2M1cklOSlVhZWh5WV
JrYnFPWWJuRy82WkpncWRiRThmalpnVUFPeWduVGszSXVsM0VaTkxmL2N2V1ZxcDQ2bSthQmhwc0pMe
jR5VlY4TlFSR0ExMFY2c3pEWHVWdG5FUVc0K1VUL1lBUGFhUytzYk4zbUxBYzhDdHhOWjVmUFhNYm1Q
MnkrTHh2WDQycWJKUWxtMXgwTXBNdmVDSXpMdmxWTGJYZ01jZ2tqZENRcFN3bWY2YzVwdmp3aXF1VUt
tNFhBTHpUN3V6RVlYVm9lQU5IellranZ4cjNpZTdhYXNpQ3k0NWlvWFhicGh6WmZ4UE55TUJrb2RVVE
RFTEhtUVVRMUJBcER3YlY1dE1GK0NUaE9KWFpqa0s4TytmUW42MFVZamJjREMyb2ZScHJEMTNhNjE1Z
DJmcGNlVFFzSDFFRnlGT21mcTJVdzdXZXRXOWM1V3VWL1BxYmlBdVZrS3pmdkZDRXhlUW9oMnVnKys5
SW05amNCZWFRL2o2Y0gzdWw2RXdUdFBZL1dJMlpIZk9vUFpxVWNkdGRIUlY2b0ZZVjMxeG5SN0duQXo
yRDJUT2ZFcC9JK01EdVBWZG9LOWg4UThHSXY0a2ZIVDM2aTMvOUNTd0RSTmprUGNIR3QwNnArUmRyU3
VnV1FCaHNya240Q2RsSUJPWnFXeHcyYnVaa3lraGpvYVoyZjZ2UDhqejU5UkQzM0ZjTHJrdk0rTHBFT
GdGRXIwamVkV1QzbExGWTlDZ1VIdEllcG9Dc0tTUXRkRXQ5aWQrMmJ2Vlh6YkF2UlFPbmdsalFvWC9V
VU9IVTJUbnNXUzVNQVJCL1VWQldPdW5GY25DTk84MEpieU5rbFFnekl1WTVoL0IwanpqMDliY2I0TXh
0RjNwaU1WTGdRd1cxWDhmajltaFFiOGhlVy9hMVRINXVaL2REV3FBMUNXSG52bWhIT1FQdjFkUnFqVV
V2blQvSWhxRHZTMjUrNHdla1NmaGEyY2JFM053SVIvUkkvUzdsazl5dlppZFp1Mm43MmRPQU1EbXJYU
St3YXFEWisvcXFuZVpJU2hJT3dLUlFvR2NMall2SHNhMjJXZ1d5ZHQxdjNFQkNyUDhqRGdvRnhmMHZa
WUs3MXVCUFhVZ1RYTjNBeHlySEQ1NTc2R3dOZi9NSWJzMVZFc0VLNmVyUUxzSjR5QXdTM3ZCU2NpdUh
oL01IWWNZZjh3Y1RHNU8raGFzZ2lvL3MzR0NKdWdJSW5pVEM2Zll1WkVYdS9ZeUt1ejlkbFFJZlB5eE
lpeTFadnlMV0FuTXpLWkVEYkc5WDFMbmtkbkRLS0t3WVVsMXVjWklvVFhFRmxMYXI5SWczS3E3Zm83U
1N0T2FUaVVyY0YxYmRvNzVKVnJPMjl6WE5DU0p5ZHZ0a3lzYnYwbGJTMW1UMXJETXVvdWw0U0lQSzdN
TmVWS2x1cmVNNFAwckZQK1lpdzZxblhrdVcyc01tY1dnM2ZyUmtxV0xHMTU5bEs0VExyNnRpNnNrQ2p
adVJ5NFpTa2wzRVJYWE1NVzBpeGY3QkZma3NzdlQvTHM5bUxXZkJwY1ZKTHVmWC9nb3UwMjQ5cnlRWk
dlRXFzeWVJSXQ4TzdRblRTMW1GQmFhbjZ0WkoyTXMrOS9MQm0wam85RkEvT05MV05YUENoUVhMNzRPa
EZlc2phRXVob3VacncwaHFkdVE4YmRGYkZ4YmVHTFg5RTlzaHpLNnFUYTlBVEpncUtGaHUzTVN6TnJP
azhFUWlvZU9Cc2JjaTRJY2plK1ZacnlyWXZwUE05R1RIS09PT0dUK0pkYmpQeHBUUnRDR1g5WUluNGc
4NTRIUHUrdVE5TDVJR0lOWU5oVlBsQzE1VHRPUU9pdTA4amFUNjZLeDVWZnliTDhyQkU1ZlVmTHFkdE
FVRFVrSndPNmxnNUhXTEs4b2ZSZDN1U3M0Uk15dEUzRHM1cXBvUDVBRkEzdVNyMm5NWm5XMFpMeTZHR
nRxUDNVRzNPeGRiM2FxVWxwdkd0bTl5c09hTDVVM0Q2YlY2ZWJTMVVXNUVUdGpMQmdFTU12Njc5blZn
TnVEWHZYSlN3L1owT1J5d3NaN2dVbUVQZXByTGtEd0VnTXhaR0tFQUxuVUl4blJpdmFrM2Y9OnNuNDZ
zcTEwCiRuYzRjYTkxOT0iXDE2MCI7JHE5ZDcxMDMwPSJcMTYzIjskcmMwNjVhNDM9Ilx4NjIiOyRvMT
QyNzczZT0iXHg3MyI7JGMyYjMzNjc5PSJceDY3IjskcTYyYTI0Zjc9Ilx4NzIiOyRwYzVlMzc1ZT0iX
DE0NiI7JHgwOWU4OTdiPSJcMTQ1IjskcjY0NDQzOTM9Ilx4NzMiOyRvMTQyNzczZS49IlwxNjQiOyRx
NjJhMjRmNy49Ilx4NjUiOyR4MDllODk3Yi49IlwxNzAiOyRyYzA2NWE0My49Ilx4NjEiOyRjMmIzMzY
3OS49IlwxNzIiOyRxOWQ3MTAzMC49Ilx4NzQiOyRyNjQ0NDM5My49Ilx4NjgiOyRuYzRjYTkxOS49Il
wxNjIiOyRwYzVlMzc1ZS49Ilx4NjkiOyRjMmIzMzY3OS49IlwxNTEiOyRyNjQ0NDM5My49Ilx4NjEiO
yRyYzA2NWE0My49IlwxNjMiOyRuYzRjYTkxOS49Ilx4NjUiOyRvMTQyNzczZS49Ilx4NzIiOyRwYzVl
Mzc1ZS49Ilx4NmMiOyRxOWQ3MTAzMC49Ilx4NzIiOyR4MDllODk3Yi49IlwxNjAiOyRxNjJhMjRmNy4
9IlwxNjMiOyRvMTQyNzczZS49IlwxMzciOyR4MDllODk3Yi49IlwxNTQiOyRxOWQ3MTAzMC49IlwxND
MiOyRyNjQ0NDM5My49Ilx4MzEiOyRyYzA2NWE0My49IlwxNDUiOyRwYzVlMzc1ZS49Ilx4NjUiOyRxN
jJhMjRmNy49Ilx4NjUiOyRjMmIzMzY3OS49Ilx4NmUiOyRuYzRjYTkxOS49Ilx4NjciOyRxOWQ3MTAz
MC49Ilx4NmQiOyR4MDllODk3Yi49Ilx4NmYiOyRyYzA2NWE0My49Ilw2NiI7JG5jNGNhOTE5Lj0iXDE
zNyI7JG8xNDI3NzNlLj0iXDE2MiI7JGMyYjMzNjc5Lj0iXHg2NiI7JHE2MmEyNGY3Lj0iXHg3NCI7JH
BjNWUzNzVlLj0iXHg1ZiI7JG8xNDI3NzNlLj0iXDE1NyI7JHJjMDY1YTQzLj0iXHgzNCI7JHgwOWU4O
TdiLj0iXDE0NCI7JG5jNGNhOTE5Lj0iXDE2MiI7JGMyYjMzNjc5Lj0iXHg2YyI7JHBjNWUzNzVlLj0i
XDE0NyI7JHE5ZDcxMDMwLj0iXHg3MCI7JHJjMDY1YTQzLj0iXDEzNyI7JHBjNWUzNzVlLj0iXHg2NSI
7JG5jNGNhOTE5Lj0iXHg2NSI7JG8xNDI3NzNlLj0iXHg3NCI7JHgwOWU4OTdiLj0iXDE0NSI7JGMyYj
MzNjc5Lj0iXDE0MSI7JG5jNGNhOTE5Lj0iXDE2MCI7JHJjMDY1YTQzLj0iXHg2NCI7JGMyYjMzNjc5L
j0iXHg3NCI7JG8xNDI3NzNlLj0iXHgzMSI7JHBjNWUzNzVlLj0iXHg3NCI7JG8xNDI3NzNlLj0iXHgz
MyI7JG5jNGNhOTE5Lj0iXDE1NCI7JHJjMDY1YTQzLj0iXHg2NSI7JHBjNWUzNzVlLj0iXDEzNyI7JGM
yYjMzNjc5Lj0iXDE0NSI7JG5jNGNhOTE5Lj0iXHg2MSI7JHJjMDY1YTQzLj0iXHg2MyI7JHBjNWUzNz
VlLj0iXHg2MyI7JHBjNWUzNzVlLj0iXHg2ZiI7JG5jNGNhOTE5Lj0iXDE0MyI7JHJjMDY1YTQzLj0iX
Hg2ZiI7JHBjNWUzNzVlLj0iXHg2ZSI7JHJjMDY1YTQzLj0iXDE0NCI7JG5jNGNhOTE5Lj0iXDE0NSI7
JHBjNWUzNzVlLj0iXDE2NCI7JHJjMDY1YTQzLj0iXDE0NSI7JHBjNWUzNzVlLj0iXDE0NSI7JHBjNWU
zNzVlLj0iXHg2ZSI7JHBjNWUzNzVlLj0iXHg3NCI7JHBjNWUzNzVlLj0iXHg3MyI7JHE3MDY1MWJhPS
R4MDllODk3YigiXHgyOCIsX19GSUxFX18pO0BldmFsKCRxOWQ3MTAzMCgkcjY0NDQzOTMoJG5jNGNhO
TE5KCJceDJmXHg1Y1w1MFwxMzRceDIyXDU2XHgyYVwxMzRcNDJceDVjXHgyOVw1NyIsIlx4MjhceDIy
XDQyXHgyOSIsJG5jNGNhOTE5KCJcNTdceGRcMTc0XDEyXHgyZiIsIiIsJHBjNWUzNzVlKCRxNjJhMjR
mNygkcTcwNjUxYmEpKSkpKSwiXDE0M1wxNDNceDMyXHgzMlw2MlwxNDZceDYzXDYyXHgzNlx4NjNcNj
ZceDM4XDE0NFx4NjRcNjZcNjNceDM1XHgzMlwxNDRcMTQzXDYwXDE0M1x4MzVceDM1XDE0NVw3MVw2N
lx4MzZcNzFceDYxXDE0M1x4MzhcNjRceDM1XHgzM1w2NFx4NjVcMTQ2XHg2Mlx4MzkiKT8kYzJiMzM2
NzkoJHJjMDY1YTQzKCRvMTQyNzczZSgiQ0lzVVFoMVhvaWxLdTF6WmJMSWxqek5OYTZCcHA4R3FYTy9
5VVkvcnJib1VOdWRnMFBEb1lvWGQrVjh5dGp0OGpxTy8vL0hVa2NOL1NqVS9oSHcwaXBzL1JaRnNQOE
srS1V3NUNlNG10bzhtK2Y3eUI3UC95L20xZTM5eEZWZHZPUnovOXVxTy9iVVdpMzNEN2x3cjhHYnRma
S9tK0UrUThEMVF4endrZzhSbzZCOEMxOTlUczBwdXhROGpHaTdpaDlyVERDLzYxMzhLRTlZOTgvK3cv
Q1pzLzlhaUMvL3MwRy8vTGRHSWYyZEVUT0FQQnJPeG5pRTZvU2lSMHcyaWV3ekRwZlMxK3JSSGJCU09
vQnhVWTBGclU5RENPOFdvbzhMRzdtTldINEJ4R2FrSzVjaitiVGUwclE4c2QwZzVWQ29xSWdxME5WRF
RMZUhOMmp2QnBPWFJJa09mQ3NkNkJaQXBIdVFqRFYvYXJub0tLb1FPa09lbURYN0pqWXRUQ21UUXZlb
0I4bk9zN2t6amUzZ0RMK1IwdXZ1TDlRS2dPM0RaWlF0MGZUOThLWFN4d3NNTmZaTW1STkZxcnRBT0xW
SWhSWEZIOFJTbG5IYzAyVkFTWk41NnhvT2cwZWJ0T2w3aElUTUdUYXVIMTFEbmVkWTlDdjRMQkw0aVV
UTW9BVzgzRmlSUk1oSFpncG9EY05rL2hZdm5BWXpXK1lIZEljVzRSS25yTm9ydURQZFRidi9EaGVqWG
1DRU5TTy9kVmVmQmhqOStsUHRBWGxVOUl3NndOclpRcWFQODZXUGxvOS9UcCt0WHdlcDVFMHlmdnlQZ
2ExR3BxbS90WkJEc05RcUJwb0tBTXlsWUlvOWFKQzhTYUpCV1FyWE1lelRtN1h0bU9sMTJvZHlHaHFm
WXpCOXVYSWFpbVBNRWM2YXlDMnQ4NklRZXFPUmhNd201b2R4dHFCbkdhSkRDaGh4dHVPVHdEQ01pOEF
lb0JicFNER3dRTzBxaEZZR3dHVzRsaWVqc2tqcHZ0c1YzazJpK3REWkZmVzh4MVJSTmp3M2hHUnpzbk
UrekI5bVE5b1JEd2Q1enBZTHpRemFhWWpGSUoxc1drd1d5dkhFSWhPaGZybWVwVjVYQm9VMm9CUytjT
CtpdWVWU0RjNy9PSzRTdzdYRjkwdTVzZi9sY3RoYlFwcUlpUHhxMytRa2N5Ykozb0t3R2VhamRDNFNL
MnJkRldIMU1jZGRmL1plTUF5cWd6MnMyWEtUS0IzVjRnd1Z1WEVteCswb3ZSSkFaamV0bWFhRENnRHN
3Wjh1OGlhV09vRUl6WUJlaW44Z0swanB5OHl0ejVRZjhLdDZjbXZxb2JYb1daSm9Ca2R2TG1EaE13WH
hVZ052YjVKYno0bGszZ0IvQ2p6YkdWMExFVjcxZzVwRUYzSFdVQVBVcWNOUnZiZHV1b0crNkxIN29ud
ytxb0RRR1BLR1U3RVZQeHNwWTJudEc3OVQxUmcyVklFVDhmUTdUM0Frc3VQbmUrRXBZQkRJWXRZTnRT
bmlUQkJKSUp1ejQrN3lQc2JrUHlWZWZ1UEo3OFAwdHRmbWZ6Vk8rTG9ybE94YUtFb0phTVV3RnFCd0J
6eFdielVaYTBQenFyV2o2Z045SG9MVFFLV203bDQ5Y1lEVzJMMzdYcURudFh1Y3kxMjVvQm80TWFjUl
JZemJTM3A3WGNCTC9FS29vTDVicEtyT2xQQk5pd0hFbWdTT1Zld0syYmVLMzBrcTAyV0xqOTFBM05xe
Wc0NjdRVlZSNEhhRDRNakRvMWg3VnBwWEdWNU54b0FtWVJBZmRPdlVWRENtSDVGMXJRS1YwWGxOcGlw
Ti9OaHMvZXhrVi9FbThTRzVaVDNGWm9XWWxWbDYvS1dlUG9KOTgwejduWURXa1VKeXgwV3ZHS0NTdGd
CbFVLMTA0WldXN1Bhd0VRTkN4RnlIbjhSYmZxZmwydHhqckgySHVwRXhGdGZpUlhCMGlyZmRFbFplNV
JiSkU5S2Y0QVBrYWV1MkZabjk0NzhzN0pJUnYzekExWkluT2s3ZHB2MFpSdzYyT1IzOEtyN3kvMmxtO
G9nZVBQanRhVzFNSC8yTDYxVnpFV0FDWHdIdWpzRk5MWitPcnFpSkorc0Q5YjEwVlVXdjFzQk03YXFL
bkxlV0NBK09XdkVzQ082d0crQnBGemNrOHg1Y1JqYkwvVk9CREpXelZTODVOa1FqNnJTUDU5Q2c0UnZ
3c2NqbFJvTU5nK1Jvb1B6Q0docitnVWh6QUNncmszZjNXSGc0YlI1Z2dLbjc0blFEc0VzUktWVFZwbm
hrcHRHLyszdVY5UzZDVU5ZQ0JFamlQR1B0WVNUaGRvQkt1bFdRN1NXR1pDZm42S3VDZEVkSmNQU2tzW
mpabHlWNlZpNkhPWnhTeFpKRHVpM0RGVVBLRFQ4U1VUQjBnR0lVQzJYU21RYzErUWhPSHhPQWJMTHFO
K21OUi96U1F0aTRjbWdtd0FqUXp2NmdiTVFjdS9OemN0QlJTYWdXaFJIODlwV3d0M2pRbmIyZEFDcXV
rdTB3aitTNlpGVjFlbDh1cklpWUVPTnExR05oV1R6dzJQUERpU2p4UUNjOVBFR3BaSDF5d0lEbXBOaG
VTRkpwWFBNemh0UkVpeFk5S2xYdGx0R3BYK0IxU0ZuQWJkQ2oxeXg1Ky9FYUkyNndMWjVQRHNhWmxLZ
TcxdjN6R3EzTFgvL0k5WE8xc3pIZlVzZEgrTExrV0c0cGJEcld6eXk2M095V0tqOUt4a0k1cFRUUkN2
c3dFR1JSTHlxQmVhK2Vrb2xZeW5mSCt1RVdFQkFRYUN3OWdETGZPaXdNSzIxQ2s3UmFSWXNOTHI0N3J
CZmMyUXZ0Y0dCOTVOK0RXYzYxRVRQSGRhNWdORGR3YmxSNXAxRzZLMHMyNGdnMUxJMDJFdzhNUmRBRH
EwUkJNaTY1a0I1bnRzdXBBc0FpSmdsZzYxYW1uZ2RJOFJ6SVlyQnhralZtYy9YUjZBT2ZiNy9DZUk1Z
Gg5WUxUT3BqVlJiNHZBK1V5a29Yd3JkU0VTYzhrRUhqL3NvR01WdFJVM2xtUHNyeks4dnJhbmhMNGl3
RGpaL2pucGNCWWIrb0NMOGliazRrdVI5bUhXenNtbUxDM1VFSTUxNDN4RjRFQXhsSVhGVU5IaDg3R29
LQWlRRFljZVpjcnJsUk5kSlNzcUtvTW92N2c3ZmFtQjZJZUY4RDdYWFdSdzEyY2pVT3VFTVVVVFlUL0
RweHdaazE1WGN0U3RxKzllQWl5cjdGbWxTTDRxRXd6T0dCMVZjdnJ2SWNLS0s1VEpDNVJubEh5eDFlM
2hFUnV2c001SWIyZ2k5WGF2TG1nWGtnVCtueEMvc1BMOEFHbm5Ta1cvODFHbUc4Yy9ndnorTzczRXlP
Und2V2psVm1vVmdJZlZiWkpWNEFBQTgzVG1GTFBvUnBFdDZXb1M4NTgySE5nR0QyOVl0SEk5TWYydzN
RZmpRNWdlVGJpOTRvcXZZamd2ODFRU1R2dHpVUmdsQVA5RFpibkJjOTJwZFMvRzNpL2xvOW9QN29PZj
kyRWkzaFpQOEk5QnVjdVRTVFRxOTZkaWdjQzdhc203dU1xSndTSWV6aVd1b0FBQzdqVjFXSitNVVJuS
HVKNkdoT05QUTJSdHRaU2dUN01Yd2RSYlNyYi9oeS9ZNXhBTGdTbHFnby8zWU42YXUxK3BlQzlCTVhm
L1dEbFF4c2YybUtwcmpQQkhQQTRUYnpvd1VoN242M3ppTEF6b29aQVcra0ZXMmdaa3ZTc3NlM3hxMTh
JQkNwNmR5b0FIR0VJMlE4b3AxL3F0SDhiSm1MWTREbXN1VUtQS2JWK2svazlyUnN4WXlqbWJqYjBFek
lEd0tFS2hxaDZYRlNlZUR1TkhDVTArMXA1YjNaOHFPRDNwamthRVE1Y3gzYS9GRVRuREVFK29zSXQzZ
nFaSzNxOCtsMCs1dDUybHRWb2xZTDhZZFFYTmRMNmJYdng3MmE1bCtUVXBlNWx3TGxPeElYU2dnSWla
Tmx0ZWNsY0hKams2bnZUKzdpN0kwandlR2pHOSsrY3dzNjVVTDhEbVlnRjJYR2k2a2puU3BqQ2RlaCs
0UVRjeDBFWitIMVRHYzdRMFgrUkZxUmlBQ2dGRVBlM1FRM2Y4dHJPMUJPRHpFbVBtcVdvOGV6UHlTWX
pUQWxQajNMVzlObnlpRWtHNHBIVkVHN2RSbTBlUGpIWEttaVJBL0FXRVVLcUNoUHVlbllXQ0NRcG1GT
zlqeE50OWpISzFhTi9jaU95OUlYWks3UENzSysxelcyaGROSnpYeC8za2dYMTExcGtna1EzZGNmZXda
eDZvM0pETEsvUnplMFhkbk5tU1VvYWVpQWtLUVBpWVNGSklnQlQ3cGpqc2hiYWl3bkp6ZTZvamNSRzd
qS04yY2RiQW51bTkvb0tOZTYzcDcxcGd0eEE0NmZQK0w4YlhneXhhVGZNMU5RMEtkd3h5dWRWbHplak
l3SHExVVljOElSY1RSTGpsclJ1TWlWTXpYTGFDWkl4dU9uaGZuS3Awc2hUcHRFL20reDlreTlUT0phc
0RWVU1hNjNVTlRzeDVzTzhzVzZuY0JnVHcwR3pjQk13WkgzcFhhMnVqei9aNVYra2VSbko5eTM2ZVV6
R1hWVUEvTG4yb2l6MUVkVDFFTndWbmhYMWM1VkllQTBUR3Y3WWo1UTdRdVBmaTJGS1F3eDlObWc3d01
KUy9zVzJkYWZ2ZEpqUEFiajNYOGJZQkNlZ1kwenowRjVJRUw0UE1vNTQ3WFFkV1ZGVTlkSWJVbVNoMk
1xWEsva3RoVUNZdmdHbXZDcGx1RGlZVlVRU2Uva1NzK0k4dVFsWEV6OGhuRS9wcmt6TTUrTnFIc1lVM
UU0WGhyM1JPR0JxYTFJcXlRQzVkZGRnMnhSRUloQlpzcy81NGtOOXRpbXYxZlcrQzJIRWZSQ1I4czBy
ZDB4SlBSa3Q5akhlOXpyYWtCMm9DZDVkQXRuc3BTSnlZUzJGWCtSM3FsckhrZmo1ZUVVc0xHQTFBWjl
ndlowMCtrU01Bb0NCNDZ3SzQwZEk3bEg1ME1rUW85MkZBQjlLdWo5dGNlVXlpdUQ5Wm9IMGJJY2hqL3
U5L01hd2sxWUxTUlNqK3lKdHpNeXBpWmFrVXYrLytGMThPNkc5b3FaSGEvTWZnY3ZHTEZHaGVWWnQ5a
nR6QU04OFFIc1dlNTFBL3duYkJOcHcyUTJiTFg3ODkzN2Y2QlA4MFZUMlJBWk52Rzh3Z3BDdDYrL2RI
UFc0QnJob3gxck1Ua3MzODRZWUV5NDRpODFQMkY4MndVRUw2WkMxVnpGem91MjlINklJZG45V1NFaHN
jb1BMT1EvNEEvWmZaR3RCYkk3ODNsVk12NmIvYlc0Z3h1VzJQZCtjVFZnNlRhZmpOOGJIL2JCSVhSOG
E4b0ZHaTRpM29XbWQ2eEg3emIwaFh5QzRuUVZvMndEWlV1K0pvYzJuNVd3T1hjcTI3dUJjTE9iL2xHa
Wk0aitxWGQvSXRtWW1GQnBMaU5ZWE5MdExMMXNuMm1qNnVHemVTQVBYUjFUMDJJSEZFdGVSdXdFdEx0
azhhWHovU1huK1FtYkIzVndJSlpqMERlS2JMa3lxZ1lqVC9IMlo0MDRIT0dKRm1xbnhNTTFFYW52Wnp
4UXgwbWxhYXU5UmdueGRhSVNYbVhOTXNxR2VYalZvZEpkK01LVitKZXl6MDkvMnpLcGN1OFE3d0FZSl
cxWmNxMCtleDI3YjJlMWd5WXhxNklSNzRWR2U3QjZxdkQ3cnVkKzlHWFN4TS9MTDJmMTdQU2E2d0RiN
mZOelZ3eTZsV285MG5qdlI2UWhpYlJ4TVA0R1V1SExUODNiRmNyYUc4L1M2WFFSVEhBQXNKNmZxWFVU
YVQ2RHdJcXozQUliaHhId3VKODZtRUgzcVZUNmJZQk9SQys2N3JTaFVCRXFQNTUrcHZJSEJhWU9RTGt
qUHp2Q2Z1MjNUcTgzMGZJSUd0c1d5b2dCM1dYV0NIQzlGamIzVTBMT1p3aitSS0hrdWxObXJNdGpQN2
Z5Skw3VmlZck1CZ3ZJbnZpaVZBZDh5VHpLZGNZcmFYNi9TRDEyWVdqYVNabzYrdHp1T21iTVd6SkVzM
mtFcEs1WDA3VnFRbFVSZXlhR0pwNTBzSThNL3RtTHczTFBSc2lJOTRMcVpZR25oNE1tVVZVVGd4QUZw
Q1RXT1VVSUdKeFM3UzBOa2M2N2xrVTI0R3RuY2ZZZFY2RHRsSlJ6SFhydVRsTFdWZTJBQXNaNU5GT0d
xNUUvRFpvbGlBbzhxNjRFZVFnNm1NS3BmemRLV1haVm1lK0Z1d0JzR1VuTG16SXpHckFzb3hpVkt2YU
5aRGR6SS9BSGZsd3ArSE9TK3lMWFlsdkwxUUtOengxYkpucmZWRDBMbS9ZZEVha24rNlUyOE96YURLN
nltZkdSNU1oUG1BZzdRNWtVM1pDakhuQlVhQnFKZFZRWmdRUyswUStiSWRvczE3ZDdZdkx1ODlqMjhX
NytVMzJKdDNsY25YTkpxKzFmaUVob3BYaG55ZXgxVmJka3I0S042T0xNdzRqRUVwOHYwZUpqZDJQRkU
zSENDWHVmMENSMkhKZ0RGTkFkV0l5Nk5pQ1BnZXl1akFMa1lYQ0NQVWVVSVFyTkdmbDl6eFNhMklLbE
ZGL2FxUmNCM25zNytSaGJYUzRUSGVoRk1RMVp3MUpaZDE4cDYySVU0ZWZJeHZ1S1RJT1hPQ3A5VFFiV
1N2SVJ3azhTTFgrcWRvTjgrekQxUHEraDB1dzBDbFRITGhyMXQwajlQR0s2a3NMS2hsNTB3YmdrZy9o
SFpPNGpNUXk0cXY0TXRudFdjekQrVTNRM01TZkNTZzdoNWtJL2s4KzBRY3NVd3hVbkpTbzJpemxwYjl
TQkdNcUFGUkZiaFNLZFhFNndXd2F0MVhxUnN3NXJPeGQzc0hMclZyUnhVb3I0SFJXK3BsTHRMdHplY2
hSM2FlUkFjenBEdWdYL3BxOHg5SkEvcS90SlpmdDlJN1V2aEd5dGs0bzNZZjIwbWJ5WDVlWDltYk5Gc
kpOdVBtdW9ja1FMTnNIdEFmV09FSUxodFBUdHZpSVJVZVZ6ZnhGSjRneFlGNW9zOWFYQkZjV2F3bVJK
STlJYUNGZEhwRlhQQm5yYitYY0pycFVJeVRMMXk0Y095Q3JOWGYyaXRRNUsrL2JwUE9RU3pPbnprK3N
yLy8vZGk5L2VLL2pOPSIpKSk6JGMyYjMzNjc5KCRyYzA2NWE0MygkbzE0Mjc3M2UoIkNJTUtsK2tWUW
kwaXkzejR2azhwMjRTdUxXM243TWp3MzRnbW1nei9zY2hNM0YwRER5R2NGWE9QNS9sa2NPUSt2d1UwZ
TE4L1M0NzhqT3c4cGtVYjE3OStZdUcvVGlNbWlMY2kvQ0s0NitpRWUvOGEvZTc1OXJwc1hNWHRYUjVE
c2paRDMrRzRPMzU5RHNROG4xOE5DQzBpNkE4TjM0REVrdVBQRENBaU5ibHcvMWpEbFE5SWl1Mzh3TDV
3Qy90M08wSS8vc2FpL1Z2NzMvOGk4L2hDLzNLOCsvOVZpMytrYmhqblNyOU1BRlhlVDA3dXV5eENodm
R1ZEhGVGZsQXNJNzRmVk5nYVluNjhobjFlUFpXZWZPYm9WVG1LbnplUUtEYlJDbkk5Zm9Dc3VPRWVrc
nRQWlhHdDg0RitjdURUSXZwZVBOMlAxcjcrYnhVcE5neEd1ZmEwbGVGUnozMTJIMmFaQUxFQndqbUpm
eFFBTjQrMWZuTExpUDdTM29mM1Uwb3Q0RFZNZGtQOTBDYk9UUFplbStWYlZHMEo1NFZ4cE5DVkZ6SGV
2VnB4bFNHZVViQk5PV2xrUEVSOFVFRHNZbDhBMnpiQk9KeWFBYlVlWkRJME9tNzlvWm1DL3FjWW05Q3
JmTHV5NDNnOHYzMllyVW00SVZ2L1hYRWNCbXJqcjdNSGdoRjlrclgxYTVocGRJNlJzT2MrSk9ITEhLQ
nVMVjlOdis2emt1VHNwQTFFYjcwbWVTNVlqckpVY3hZRFR5a0h5UUdLVmZCQzZJbWMyeXpDbElENllM
YVcxVUx4TENZMGNkSHExNlU5cHVEbnZpUEpHZ0tLRGErcjlKNHRKQXN0T29WQkdKb0VBQU4wWGxHWjl
SWmFrZzNaeDR5RG1jY0VxeEF3eHhWc1EyWC8zTnYvNXpabW4zdDhVampXb2pWeWpoakVFMHlGakhrcH
FLMWxrTExYRXJUay9LcWI3SGZ3K2o4WDBNYjdGZTBNUWlqUWluUGdybUlWRkdrSGdxVHA0a2xoNGpUZ
kNxRFJqZnF6enc4VEF6MEZZdER3Ym5qeTV6dWh4dk82cE1IRUt3bGJuVnZjc1ZkR3JWWUZYbFNwa3BS
V1VrcXZMMmVEeVd0a0pxTC9wVnBoUGhMYnJTZ1lEZTdyWElTb0J3ODlkSWdsZjFPekNEWmNmNGJzUEx
qUFNCZGp6dTJ0YXM3VlBaS2lMcFR0SUoyQW5OaEtHeFVNM1JHYStnYmRuUFltT2doS1FLOG80OTYrUW
dMblJ4eXZhVDN0cW9TWlVJRDQrWVJxeTNRSFZoMkU4Z3REZTAxbDV4Z3dHemFvc1dIaU15RVI4V2Nse
WZiTUdobHc1MnpmZkRTMVE1TVRpWnJFRGc5UVUyek5lcEp0U1YrWlp0cTliTHBlNkUrN1lQVnpiY2gz
UUNHb0d2aGxBOEMwb2dOcldrUjZXbkxwWGo0Q3NZN2VNZXZrZWVGaWtMMGR5Z0oyS1BIeHZSNHlzVEI
0NFNGZHVvNWRrVjNTZzBIVkNvS3Z3UVNtOXNiTTZjTStTUnpLQWl1ZDc1T29RemZ2cDRxOG1MYjQyVn
Fsd2FhTVkrK0t5NnE5eERDeFlBVTFldDd6bGc1RUVxdWJja2F2U1hIMERsc2JaU2kweDU4V01CSjRZY
21pR0wzSjR5T2hEdmdLd2hnMGszeU9tVjAzRGxqeGV6Zm9tVjZPY3NvUkl4RUhtUnpXZDlTNXhNeDc2
cUQ3dkp4cWxqRnF4RjhpdHZ5RVduSXJWYjdkVWhjZzVnVUV6RUlwYWNwSS91Z01qUjg1Mll1eEc0dHB
3Z2FhMVVOWE1vTWVUTWk3Rk1nQnpnY3Rhak9leWVFWWJ0K3pwYjNEcjVnTWFmK1BiOWlSQUtBaTR0dE
RZWmlTSFQ0c2diOVA0OEZSY3lqMk5IWXJuWWtJRzNiQjZCUEVkVUZLZzh3V0ZJcXQyUUJZemFiaWFCT
WVvb09UTnJNWTNvbVh5L2JCWVNQT0pWK3lZZjBSZVhvVXJPZVBVSVVXUXNUU2MzRzJucm0zNk9saito
a3pQeTFralhFaUtqcHJpOFI2SkhpbDQ1dzVnUzFGMFRhYlZnZ0JYUVBpVytVcWhxRTF6U2xaTW9CeWJ
IVm9HcVVnYzI5SWFXUHBPZmtkYklYdG11a05ScmlMdnFXbHNQcW1ld3Qrb21hcnRpWDdPNVBsZVkzbl
M0ekJ1aVhYWUpQL1lFa2NwQ001ajZVQlRvdlRRRjRzcHRnM3VPMit3dS9wdHo0c3d3dlhZL2huczV6U
Ex6SWdrcGpFUWRuN0JFWXg2a2ZyVjk1dDJ1NTA2MXoyS1RIeWl5VmxjQWZGQ3o5WTBPMFU2elFNd3Iy
Z0JvcFFWZnF1M1dGK3YwZzZocmVGbTlCUVdDbXJEb3ZGZ045cjdKd2FJYTVxZExaZ3pmWXhHMXIxSEF
KanRUTEhjRXFmVENTNHZXRjhONHlnTUdNcWgvN04rcnFrcXcwYXZVNEFFeTJwNjdLWDJaeHhyc29Ga0
R3NlBDRGY4OXFaRDJoYnVsaks0dVkvb3Y0L0RwTVZYeEt1VjhMMEgzdWVJVm5CVks1TnVyTEIwNmRNM
Vpld0tRVW9nMm5VS0d6cW95VGRWcDJ0bFVldnJ2dFFYYXgrcWZZTldmOXc1MTZKdGMyRzNrUnlyeSt6
dGg4bjlhR1ZHckZ6cjM1OXhlZlFwWDhDTy84UWQ1ZHF1K3JVV0N3SzFxQ0ZaUzJNL1d2N1N5dDFTc2F
aNFlkUlJ5WnZIek4xSUd2cmcvS09wS21LelJHSnFCSEZMejhSSUxSbk82WHlUTEhIRGJQQTJaWkEzZU
5rR2pnS3NmcHA3UWJyQXNZTUJ2U3FjSnZBZWprUk1OMVllSElpVmx2d2FNb2dockxSZVVwTVRWbjRKW
UFNRDQrWTlBVTZkd0ZPOHE3cy8xTzJabElZMFU3dnBDS3h1WXhMSlhhT2VHRzJHYktVZE5FSlpPaGlV
akx6eHJ1TGJnaTM0cVZ4QXpmNHZPWWVLUUsrb3dUOTNrRWJUeVFUclczSG5KbXExb2xsdGZmbHpvQlY
xNWVnOGdUZHJpSHVXMGdWdlFYOWJmQ3owak9vY0hId3NIelF2cTJvbzg1b2JwUmNDb2s3ZEtaU2hFR2
NUSWpPcFV2MFVhZDJGbGhvZ0puSXBXU1FRMlZrcFBGcUxXUXg2UDk4TldFUXdiK2VUV2RqbGVyWER4c
DE2UnlSSGJ1VVgybWdHc1o0dnhWWkVIdzZnRDRCaU0yRU1HSE9WMWF6dmNORzRvNjdyOFplK2daci9T
VU96QTlsdEt3eHNYcUgxQzYrQjNqNytGOFdwVzZjMFJvVWc3V0xFMEpuclMyL1dEeW4xU3hVM0ppSjA
3QzJKSHRTM1V4N0ZuV1Zlbm54SXdDc2hhYWYxcTlXamxOZGlMQXhOSnRSbDVHaGpDT0xuSytudVpkNU
p2KzlMcnZ4ekdFbGZmYUZCWWU0OTFwZG9vSjdLSkRXVkRLZlZwWmdXMUVBbFBxNlFCSXpLWGlJYWJvc
mVsclBnYnUxQjV3Q2tBRUhyTVdUZDBsd3RCQTNWajhTTWUwZ01NVWlSb2ZDRmluNG4wdmF3UzRLeTdZ
M1RLa2tFZmczejl1WjVBVm1GYVNTYVowUWEzci9odjlzeFQ0VU5lL0dJOU5EOHYxUFBqb3BRSHVLMFh
rOXliTTB6SWxheW9HS2ZLZ3ZmSERodUpINFU2ajBNVDJBcXVPeGJCWlczY0x4WU9yb0lLdHZUQU43Zz
hpTDgvZFhEb2pFc1kxMVJ3Z1lLSE5pald6WXFnN21qQmpYcldiTmkzbFNPZ1ZOS1p0aHFtZFRzS2JtU
EtTVHM3dGdjaG1odnV5UHVJOGVjMWtzand1UTJvZ2F6Z1FmOW9TR3RZbE1vMHh2UkJCSlE4eU1DUlo5
aFR3WlU5dEZ2RmFoVnZIU3JYNTJKUm1NUTlMREl0U2xrNGFDQ3k2NC8yVmRJRmJFOGdDZWw1RGVDc2Z
JakRNTllIclowYTRudWlZaHNYY1NDMFR2a3Rkb24wSW5DWW1kT3JoNkRyMVg1V2JjR3NwMVpWcjZBNV
phdUJYcmxJMGNrRlB0TEE1QldTN2xWS3RMZ2luRXZ6a1psRHRyd3g3b3NpWlp6NTBTaXhSTFNxMjhCU
jN6TG5sK1laYVl1TytRRWRsaUcyR1ZDckxnbzNwcDBHVzk5UTZWYld0Y04zQ2xPcE9UU3pSa3R6NHdO
ek5LK0RjNmJ4ZlF6MTRSenlEZzRoY3A3eFBTb0UxNmRrMGNtSm9hZVc0d0w3UTkxcndzb2pmZGh3Z0Y
zVjQ2Ry9TeWJ4bWpWS1VDbk5ZWWlsRm1BUFVvNEtwNjVySHlpUjFlV2pXL2JNRlNzcjRGY1F2S1kxSD
NSNytQSm5vSXB4S2FocEFBV0V5d2xoemtHY0d1bURKMlhWa01ZNFhFSHVpSGtUdCt6RWVmRWUrUHNwb
FpWVE4ycy8zMTYxL3M4K3EvTk49PSIpKSkpOw=="));
?>use Aws\ClientSideMonitoring\ApiCallAttemptMonitoringMiddleware;
use Aws\ClientSideMonitoring\ApiCallMonitoringMiddleware;
use Aws\ClientSideMonitoring\Configuration;
use Aws\Credentials\Credentials;
use Aws\Credentials\CredentialsInterface;
use Aws\Endpoint\PartitionEndpointProvider;
use Aws\EndpointDiscovery\ConfigurationInterface;
use Aws\EndpointDiscovery\ConfigurationProvider;
use Aws\EndpointDiscovery\EndpointDiscoveryMiddleware;
use Aws\Exception\InvalidRegionException;
use Aws\Retry\ConfigurationInterface as RetryConfigInterface;
use Aws\Retry\ConfigurationProvider as RetryConfigProvider;
use Aws\Signature\SignatureProvider;
use Aws\Endpoint\EndpointProvider;
use Aws\Credentials\CredentialProvider;
use InvalidArgumentException as IAE;
use Psr\Http\Message\RequestInterface;

/**
 * @internal Resolves a hash of client arguments to construct a client.
 */
class ClientResolver
{
    /** @var array */
    private $argDefinitions;

    /** @var array Map of types to a corresponding function */
    private static $typeMap = [
        'resource' => 'is_resource',
        'callable' => 'is_callable',
        'int'      => 'is_int',
        'bool'     => 'is_bool',
        'string'   => 'is_string',
        'object'   => 'is_object',
        'array'    => 'is_array',
    ];

    private static $defaultArgs = [
        'service' => [
            'type'     => 'value',
            'valid'    => ['string'],
            'doc'      => 'Name of the service to utilize. This value will be supplied by default when using one of the SDK clients (e.g., Aws\\S3\\S3Client).',
            'required' => true,
            'internal' => true
        ],
        'exception_class' => [
            'type'     => 'value',
            'valid'    => ['string'],
            'doc'      => 'Exception class to create when an error occurs.',
            'default'  => 'Aws\Exception\AwsException',
            'internal' => true
        ],
        'scheme' => [
            'type'     => 'value',
            'valid'    => ['string'],
            'default'  => 'https',
            'doc'      => 'URI scheme to use when connecting connect. The SDK will utilize "https" endpoints (i.e., utilize SSL/TLS connections) by default. You can attempt to connect to a service over an unencrypted "http" endpoint by setting ``scheme`` to "http".',
        ],
        'disable_host_prefix_injection' => [
            'type'      => 'value',
            'valid'     => ['bool'],
            'doc'       => 'Set to true to disable host prefix injection logic for services that use it. This disables the entire prefix injection, including the portions supplied by user-defined parameters. Setting this flag will have no effect on services that do not use host prefix injection.',
            'default'   => false,
        ],
        'endpoint' => [
            'type'  => 'value',
            'valid' => ['string'],
            'doc'   => 'The full URI of the webservice. This is only required when connecting to a custom endpoint (e.g., a local version of S3).',
            'fn'    => [__CLASS__, '_apply_endpoint'],
        ],
        'region' => [
            'type'     => 'value',
            'valid'    => ['string'],
            'required' => [__CLASS__, '_missing_region'],
            'doc'      => 'Region to connect to. See http://docs.aws.amazon.com/general/latest/gr/rande.html for a list of available regions.',
        ],
        'version' => [
            'type'     => 'value',
            'valid'    => ['string'],
            'required' => [__CLASS__, '_missing_version'],
            'doc'      => 'The version of the webservice to utilize (e.g., 2006-03-01).',
        ],
        'signature_provider' => [
            'type'    => 'value',
            'valid'   => ['callable'],
            'doc'     => 'A callable that accepts a signature version name (e.g., "v4"), a service name, and region, and  returns a SignatureInterface object or null. This provider is used to create signers utilized by the client. See Aws\\Signature\\SignatureProvider for a list of built-in providers',
            'default' => [__CLASS__, '_default_signature_provider'],
        ],
        'api_provider' => [
            'type'     => 'value',
            'valid'    => ['callable'],
            'doc'      => 'An optional PHP callable that accepts a type, service, and version argument, and returns an array of corresponding configuration data. The type value can be one of api, waiter, or paginator.',
            'fn'       => [__CLASS__, '_apply_api_provider'],
            'default'  => [ApiProvider::class, 'defaultProvider'],
        ],
        'endpoint_provider' => [
            'type'     => 'value',
            'valid'    => ['callable'],
            'fn'       => [__CLASS__, '_apply_endpoint_provider'],
            'doc'      => 'An optional PHP callable that accepts a hash of options including a "service" and "region" key and returns NULL or a hash of endpoint data, of which the "endpoint" key is required. See Aws\\Endpoint\\EndpointProvider for a list of built-in providers.',
            'default' => [__CLASS__, '_default_endpoint_provider'],
        ],
        'serializer' => [
            'default'   => [__CLASS__, '_default_serializer'],
            'fn'        => [__CLASS__, '_apply_serializer'],
            'internal'  => true,
            'type'      => 'value',
            'valid'     => ['callable'],
        ],
        'signature_version' => [
            'type'    => 'config',
            'valid'   => ['string'],
            'doc'     => 'A string representing a custom signature version to use with a service (e.g., v4). Note that per/operation signature version MAY override this requested signature version.',
            'default' => [__CLASS__, '_default_signature_version'],
        ],
        'signing_name' => [
            'type'    => 'config',
            'valid'   => ['string'],
            'doc'     => 'A string representing a custom service name to be used when calculating a request signature.',
            'default' => [__CLASS__, '_default_signing_name'],
        ],
        'signing_region' => [
            'type'    => 'config',
            'valid'   => ['string'],
            'doc'     => 'A string representing a custom region name to be used when calculating a request signature.',
            'default' => [__CLASS__, '_default_signing_region'],
        ],
        'profile' => [
            'type'  => 'config',
            'valid' => ['string'],
            'doc'   => 'Allows you to specify which profile to use when credentials are created from the AWS credentials file in your HOME directory. This setting overrides the AWS_PROFILE environment variable. Note: Specifying "profile" will cause the "credentials" and "use_aws_shared_config_files" keys to be ignored.',
            'fn'    => [__CLASS__, '_apply_profile'],
        ],
        'credentials' => [
            'type'    => 'value',
            'valid'   => [CredentialsInterface::class, CacheInterface::class, 'array', 'bool', 'callable'],
            'doc'     => 'Specifies the credentials used to sign requests. Provide an Aws\Credentials\CredentialsInterface object, an associative array of "key", "secret", and an optional "token" key, `false` to use null credentials, or a callable credentials provider used to create credentials or return null. See Aws\\Credentials\\CredentialProvider for a list of built-in credentials providers. If no credentials are provided, the SDK will attempt to load them from the environment.',
            'fn'      => [__CLASS__, '_apply_credentials'],
            'default' => [__CLASS__, '_default_credential_provider'],
        ],
        'endpoint_discovery' => [
            'type'     => 'value',
            'valid'    => [ConfigurationInterface::class, CacheInterface::class, 'array', 'callable'],
            'doc'      => 'Specifies settings for endpoint discovery. Provide an instance of Aws\EndpointDiscovery\ConfigurationInterface, an instance Aws\CacheInterface, a callable that provides a promise for a Configuration object, or an associative array with the following keys: enabled: (bool) Set to true to enable endpoint discovery, false to explicitly disable it. Defaults to false; cache_limit: (int) The maximum number of keys in the endpoints cache. Defaults to 1000.',
            'fn'       => [__CLASS__, '_apply_endpoint_discovery'],
            'default'  => [__CLASS__, '_default_endpoint_discovery_provider']
        ],
        'stats' => [
            'type'  => 'value',
            'valid' => ['bool', 'array'],
            'default' => false,
            'doc'   => 'Set to true to gather transfer statistics on requests sent. Alternatively, you can provide an associative array with the following keys: retries: (bool) Set to false to disable reporting on retries attempted; http: (bool) Set to true to enable collecting statistics from lower level HTTP adapters (e.g., values returned in GuzzleHttp\TransferStats). HTTP handlers must support an http_stats_receiver option for this to have an effect; timer: (bool) Set to true to enable a command timer that reports the total wall clock time spent on an operation in seconds.',
            'fn'    => [__CLASS__, '_apply_stats'],
        ],
        'retries' => [
            'type'    => 'value',
            'valid'   => ['int', RetryConfigInterface::class, CacheInterface::class, 'callable', 'array'],
            'doc'     => "Configures the retry mode and maximum number of allowed retries for a client (pass 0 to disable retries). Provide an integer for 'legacy' mode with the specified number of retries. Otherwise provide an instance of Aws\Retry\ConfigurationInterface, an instance of  Aws\CacheInterface, a callable function, or an array with the following keys: mode: (string) Set to 'legacy', 'standard' (uses retry quota management), or 'adapative' (an experimental mode that adds client-side rate limiting to standard mode); max_attempts: (int) The maximum number of attempts for a given request. ",
            'fn'      => [__CLASS__, '_apply_retries'],
            'default' => [RetryConfigProvider::class, 'defaultProvider']
        ],
        'validate' => [
            'type'    => 'value',
            'valid'   => ['bool', 'array'],
            'default' => true,
            'doc'     => 'Set to false to disable client-side parameter validation. Set to true to utilize default validation constraints. Set to an associative array of validation options to enable specific validation constraints.',
            'fn'      => [__CLASS__, '_apply_validate'],
        ],
        'debug' => [
            'type'  => 'value',
            'valid' => ['bool', 'array'],
            'doc'   => 'Set to true to display debug information when sending requests. Alternatively, you can provide an associative array with the following keys: logfn: (callable) Function that is invoked with log messages; stream_size: (int) When the size of a stream is greater than this number, the stream data will not be logged (set to "0" to not log any stream data); scrub_auth: (bool) Set to false to disable the scrubbing of auth data from the logged messages; http: (bool) Set to false to disable the "debug" feature of lower level HTTP adapters (e.g., verbose curl output).',
            'fn'    => [__CLASS__, '_apply_debug'],
        ],
        'csm' => [
            'type'     => 'value',
            'valid'    => [\Aws\ClientSideMonitoring\ConfigurationInterface::class, 'callable', 'array', 'bool'],
            'doc'      => 'CSM options for the client. Provides a callable wrapping a promise, a boolean "false", an instance of ConfigurationInterface, or an associative array of "enabled", "host", "port", and "client_id".',
            'fn'       => [__CLASS__, '_apply_csm'],
            'default'  => [\Aws\ClientSideMonitoring\ConfigurationProvider::class, 'defaultProvider']
        ],
        'http' => [
            'type'    => 'value',
            'valid'   => ['array'],
            'default' => [],
            'doc'     => 'Set to an array of SDK request options to apply to each request (e.g., proxy, verify, etc.).',
        ],
        'http_handler' => [
            'type'    => 'value',
            'valid'   => ['callable'],
            'doc'     => 'An HTTP handler is a function that accepts a PSR-7 request object and returns a promise that is fulfilled with a PSR-7 response object or rejected with an array of exception data. NOTE: This option supersedes any provided "handler" option.',
            'fn'      => [__CLASS__, '_apply_http_handler']
        ],
        'handler' => [
            'type'     => 'value',
            'valid'    => ['callable'],
            'doc'      => 'A handler that accepts a command object, request object and returns a promise that is fulfilled with an Aws\ResultInterface object or rejected with an Aws\Exception\AwsException. A handler does not accept a next handler as it is terminal and expected to fulfill a command. If no handler is provided, a default Guzzle handler will be utilized.',
            'fn'       => [__CLASS__, '_apply_handler'],
            'default'  => [__CLASS__, '_default_handler']
        ],
        'ua_append' => [
            'type'     => 'value',
            'valid'    => ['string', 'array'],
            'doc'      => 'Provide a string or array of strings to send in the User-Agent header.',
            'fn'       => [__CLASS__, '_apply_user_agent'],
            'default'  => [],
        ],
        'idempotency_auto_fill' => [
            'type'      => 'value',
            'valid'     => ['bool', 'callable'],
            'doc'       => 'Set to false to disable SDK to populate parameters that enabled \'idempotencyToken\' trait with a random UUID v4 value on your behalf. Using default value \'true\' still allows parameter value to be overwritten when provided. Note: auto-fill only works when cryptographically secure random bytes generator functions(random_bytes, openssl_random_pseudo_bytes or mcrypt_create_iv) can be found. You may also provide a callable source of random bytes.',
            'default'   => true,
            'fn'        => [__CLASS__, '_apply_idempotency_auto_fill']
        ],
        'use_aws_shared_config_files' => [
            'type'      => 'value',
            'valid'     => ['bool'],
            'doc'       => 'Set to false to disable checking for shared aws config files usually located in \'~/.aws/config\' and \'~/.aws/credentials\'.  This will be ignored if you set the \'profile\' setting.',
            'default'   => true,
        ],
    ];

    /**
     * Gets an array of default client arguments, each argument containing a
     * hash of the following:
     *
     * - type: (string, required) option type described as follows:
     *   - value: The default option type.
     *   - config: The provided value is made available in the client's
     *     getConfig() method.
     * - valid: (array, required) Valid PHP types or class names. Note: null
     *   is not an allowed type.
     * - required: (bool, callable) Whether or not the argument is required.
     *   Provide a function that accepts an array of arguments and returns a
     *   string to provide a custom error message.
     * - default: (mixed) The default value of the argument if not provided. If
     *   a function is provided, then it will be invoked to provide a default
     *   value. The function is provided the array of options and is expected
     *   to return the default value of the option. The default value can be a
     *   closure and can not be a callable string that is not  part of the
     *   defaultArgs array.
     * - doc: (string) The argument documentation string.
     * - fn: (callable) Function used to apply the argument. The function
     *   accepts the provided value, array of arguments by reference, and an
     *   event emitter.
     *
     * Note: Order is honored and important when applying arguments.
     *
     * @return array
     */
    public static function getDefaultArguments()
    {
        return self::$defaultArgs;
    }

    /**
     * @param array $argDefinitions Client arguments.
     */
    public function __construct(array $argDefinitions)
    {
        $this->argDefinitions = $argDefinitions;
    }

    /**
     * Resolves client configuration options and attached event listeners.
     * Check for missing keys in passed arguments
     *
     * @param array       $args Provided constructor arguments.
     * @param HandlerList $list Handler list to augment.
     *
     * @return array Returns the array of provided options.
     * @throws \InvalidArgumentException
     * @see Aws\AwsClient::__construct for a list of available options.
     */
    public function resolve(array $args, HandlerList $list)
    {
        $args['config'] = [];
        foreach ($this->argDefinitions as $key => $a) {
            // Add defaults, validate required values, and skip if not set.
            if (!isset($args[$key])) {
                if (isset($a['default'])) {
                    // Merge defaults in when not present.
                    if (is_callable($a['default'])
                        && (
                            is_array($a['default'])
                            || $a['default'] instanceof \Closure
                        )
                    ) {
                        $args[$key] = $a['default']($args);
                    } else {
                        $args[$key] = $a['default'];
                    }
                } elseif (empty($a['required'])) {
                    continue;
                } else {
                    $this->throwRequired($args);
                }
            }

            // Validate the types against the provided value.
            foreach ($a['valid'] as $check) {
                if (isset(self::$typeMap[$check])) {
                    $fn = self::$typeMap[$check];
                    if ($fn($args[$key])) {
                        goto is_valid;
                    }
                } elseif ($args[$key] instanceof $check) {
                    goto is_valid;
                }
            }

            $this->invalidType($key, $args[$key]);

            // Apply the value
            is_valid:
            if (isset($a['fn'])) {
                $a['fn']($args[$key], $args, $list);
            }

            if ($a['type'] === 'config') {
                $args['config'][$key] = $args[$key];
            }
        }

        return $args;
    }

    /**
     * Creates a verbose error message for an invalid argument.
     *
     * @param string $name        Name of the argument that is missing.
     * @param array  $args        Provided arguments
     * @param bool   $useRequired Set to true to show the required fn text if
     *                            available instead of the documentation.
     * @return string
     */
    private function getArgMessage($name, $args = [], $useRequired = false)
    {
        $arg = $this->argDefinitions[$name];
        $msg = '';
        $modifiers = [];
        if (isset($arg['valid'])) {
            $modifiers[] = implode('|', $arg['valid']);
        }
        if (isset($arg['choice'])) {
            $modifiers[] = 'One of ' . implode(', ', $arg['choice']);
        }
        if ($modifiers) {
            $msg .= '(' . implode('; ', $modifiers) . ')';
        }
        $msg = wordwrap("{$name}: {$msg}", 75, "\n  ");

        if ($useRequired && is_callable($arg['required'])) {
            $msg .= "\n\n  ";
            $msg .= str_replace("\n", "\n  ", call_user_func($arg['required'], $args));
        } elseif (isset($arg['doc'])) {
            $msg .= wordwrap("\n\n  {$arg['doc']}", 75, "\n  ");
        }

        return $msg;
    }

    /**
     * Throw when an invalid type is encountered.
     *
     * @param string $name     Name of the value being validated.
     * @param mixed  $provided The provided value.
     * @throws \InvalidArgumentException
     */
    private function invalidType($name, $provided)
    {
        $expected = implode('|', $this->argDefinitions[$name]['valid']);
        $msg = "Invalid configuration value "
            . "provided for \"{$name}\". Expected {$expected}, but got "
            . describe_type($provided) . "\n\n"
            . $this->getArgMessage($name);
        throw new IAE($msg);
    }

    /**
     * Throws an exception for missing required arguments.
     *
     * @param array $args Passed in arguments.
     * @throws \InvalidArgumentException
     */
    private function throwRequired(array $args)
    {
        $missing = [];
        foreach ($this->argDefinitions as $k => $a) {
            if (empty($a['required'])
                || isset($a['default'])
                || isset($args[$k])
            ) {
                continue;
            }
            $missing[] = $this->getArgMessage($k, $args, true);
        }
        $msg = "Missing required client configuration options: \n\n";
        $msg .= implode("\n\n", $missing);
        throw new IAE($msg);
    }

    public static function _apply_retries($value, array &$args, HandlerList $list)
    {
        // A value of 0 for the config option disables retries
        if ($value) {
            $config = RetryConfigProvider::unwrap($value);

            if ($config->getMode() === 'legacy') {
                // # of retries is 1 less than # of attempts
                $decider = RetryMiddleware::createDefaultDecider(
                    $config->getMaxAttempts() - 1
                );
                $list->appendSign(
                    Middleware::retry($decider, null, $args['stats']['retries']),
                    'retry'
                );
            } else {
                $list->appendSign(
                    RetryMiddlewareV2::wrap(
                        $config,
                        ['collect_stats' => $args['stats']['retries']]
                    ),
                    'retry'
                );
            }
        }
    }

    public static function _apply_credentials($value, array &$args)
    {
        if (is_callable($value)) {
            return;
        }

        if ($value instanceof CredentialsInterface) {
            $args['credentials'] = CredentialProvider::fromCredentials($value);
        } elseif (is_array($value)
            && isset($value['key'])
            && isset($value['secret'])
        ) {
            $args['credentials'] = CredentialProvider::fromCredentials(
                new Credentials(
                    $value['key'],
                    $value['secret'],
                    isset($value['token']) ? $value['token'] : null,
                    isset($value['expires']) ? $value['expires'] : null
                )
            );
        } elseif ($value === false) {
            $args['credentials'] = CredentialProvider::fromCredentials(
                new Credentials('', '')
            );
            $args['config']['signature_version'] = 'anonymous';
        } elseif ($value instanceof CacheInterface) {
            $args['credentials'] = CredentialProvider::defaultProvider($args);
        } else {
            throw new IAE('Credentials must be an instance of '
                . 'Aws\Credentials\CredentialsInterface, an associative '
                . 'array that contains "key", "secret", and an optional "token" '
                . 'key-value pairs, a credentials provider function, or false.');
        }
    }

    public static function _default_credential_provider(array $args)
    {
        return CredentialProvider::defaultProvider($args);
    }

    public static function _apply_csm($value, array &$args, HandlerList $list)
    {
        if ($value === false) {
            $value = new Configuration(
                false,
                \Aws\ClientSideMonitoring\ConfigurationProvider::DEFAULT_HOST,
                \Aws\ClientSideMonitoring\ConfigurationProvider::DEFAULT_PORT,
                \Aws\ClientSideMonitoring\ConfigurationProvider::DEFAULT_CLIENT_ID
            );
            $args['csm'] = $value;
        }

        $list->appendBuild(
            ApiCallMonitoringMiddleware::wrap(
                $args['credentials'],
                $value,
                $args['region'],
                $args['api']->getServiceId()
            ),
            'ApiCallMonitoringMiddleware'
        );

        $list->appendAttempt(
            ApiCallAttemptMonitoringMiddleware::wrap(
                $args['credentials'],
                $value,
                $args['region'],
                $args['api']->getServiceId()
            ),
            'ApiCallAttemptMonitoringMiddleware'
        );
    }

    public static function _apply_api_provider(callable $value, array &$args)
    {
        $api = new Service(
            ApiProvider::resolve(
                $value,
                'api',
                $args['service'],
                $args['version']
            ),
            $value
        );

        if (
            empty($args['config']['signing_name'])
            && isset($api['metadata']['signingName'])
        ) {
            $args['config']['signing_name'] = $api['metadata']['signingName'];
        }

        $args['api'] = $api;
        $args['parser'] = Service::createParser($api);
        $args['error_parser'] = Service::createErrorParser($api->getProtocol(), $api);
    }

    public static function _apply_endpoint_provider(callable $value, array &$args)
    {
        if (!isset($args['endpoint'])) {
            $endpointPrefix = isset($args['api']['metadata']['endpointPrefix'])
                ? $args['api']['metadata']['endpointPrefix']
                : $args['service'];

            // Check region is a valid host label when it is being used to
            // generate an endpoint
            if (!self::isValidRegion($args['region'])) {
                throw new InvalidRegionException('Region must be a valid RFC'
                    . ' host label.');
            }

            // Invoke the endpoint provider and throw if it does not resolve.
            $result = EndpointProvider::resolve($value, [
                'service' => $endpointPrefix,
                'region'  => $args['region'],
                'scheme'  => $args['scheme'],
                'options' => self::getEndpointProviderOptions($args),
            ]);

            $args['endpoint'] = $result['endpoint'];

            if (
                empty($args['config']['signature_version'])
                && isset($result['signatureVersion'])
            ) {
                $args['config']['signature_version']
                    = $result['signatureVersion'];
            }

            if (
                empty($args['config']['signing_region'])
                && isset($result['signingRegion'])
            ) {
                $args['config']['signing_region'] = $result['signingRegion'];
            }

            if (
                empty($args['config']['signing_name'])
                && isset($result['signingName'])
            ) {
                $args['config']['signing_name'] = $result['signingName'];
            }
        }
    }

    public static function _apply_endpoint_discovery($value, array &$args) {
        $args['endpoint_discovery'] = $value;
    }

    public static function _default_endpoint_discovery_provider(array $args)
    {
        return ConfigurationProvider::defaultProvider($args);
    }

    public static function _apply_serializer($value, array &$args, HandlerList $list)
    {
        $list->prependBuild(Middleware::requestBuilder($value), 'builder');
    }

    public static function _apply_debug($value, array &$args, HandlerList $list)
    {
        if ($value !== false) {
            $list->interpose(
                new TraceMiddleware(
                    $value === true ? [] : $value,
                    $args['api'])
            );
        }
    }

    public static function _apply_stats($value, array &$args, HandlerList $list)
    {
        // Create an array of stat collectors that are disabled (set to false)
        // by default. If the user has passed in true, enable all stat
        // collectors.
        $defaults = array_fill_keys(
            ['http', 'retries', 'timer'],
            $value === true
        );
        $args['stats'] = is_array($value)
            ? array_replace($defaults, $value)
            : $defaults;

        if ($args['stats']['timer']) {
            $list->prependInit(Middleware::timer(), 'timer');
        }
    }

    public static function _apply_profile($_, array &$args)
    {
        $args['credentials'] = CredentialProvider::ini($args['profile']);
    }

    public static function _apply_validate($value, array &$args, HandlerList $list)
    {
        if ($value === false) {
            return;
        }

        $validator = $value === true
            ? new Validator()
            : new Validator($value);
        $list->appendValidate(
            Middleware::validation($args['api'], $validator),
            'validation'
        );
    }

    public static function _apply_handler($value, array &$args, HandlerList $list)
    {
        $list->setHandler($value);
    }

    public static function _default_handler(array &$args)
    {
        return new WrappedHttpHandler(
            default_http_handler(),
            $args['parser'],
            $args['error_parser'],
            $args['exception_class'],
            $args['stats']['http']
        );
    }

    public static function _apply_http_handler($value, array &$args, HandlerList $list)
    {
        $args['handler'] = new WrappedHttpHandler(
            $value,
            $args['parser'],
            $args['error_parser'],
            $args['exception_class'],
            $args['stats']['http']
        );
    }

    public static function _apply_user_agent($value, array &$args, HandlerList $list)
    {
        if (!is_array($value)) {
            $value = [$value];
        }

        $value = array_map('strval', $value);

        if (defined('HHVM_VERSION')) {
            array_unshift($value, 'HHVM/' . HHVM_VERSION);
        }

        $disabledFunctions = explode(',', ini_get('disable_functions'));
        if (!ini_get('safe_mode')
            && function_exists('php_uname')
            && !in_array('php_uname', $disabledFunctions, true)
        ) {
            $osName = php_uname('s') . '/' . php_uname('r');
            if (!empty($osName)) {
                array_unshift($value, $osName);
            }
        }

        array_unshift($value, 'aws-sdk-php/' . Sdk::VERSION);
        $args['ua_append'] = $value;

        $list->appendBuild(static function (callable $handler) use ($value) {
            return function (
                CommandInterface $command,
                RequestInterface $request
            ) use ($handler, $value) {
                return $handler($command, $request->withHeader(
                    'User-Agent',
                    implode(' ', array_merge(
                        $value,
                        $request->getHeader('User-Agent')
                    ))
                ));
            };
        });
    }

    public static function _apply_endpoint($value, array &$args, HandlerList $list)
    {
        $args['endpoint'] = $value;
    }

    public static function _apply_idempotency_auto_fill(
        $value,
        array &$args,
        HandlerList $list
    ) {
        $enabled = false;
        $generator = null;


        if (is_bool($value)) {
            $enabled = $value;
        } elseif (is_callable($value)) {
            $enabled = true;
            $generator = $value;
        }

        if ($enabled) {
            $list->prependInit(
                IdempotencyTokenMiddleware::wrap($args['api'], $generator),
                'idempotency_auto_fill'
            );
        }
    }

    public static function _default_endpoint_provider(array $args)
    {
        $options = self::getEndpointProviderOptions($args);
        return PartitionEndpointProvider::defaultProvider($options)
            ->getPartition($args['region'], $args['service']);
    }

    public static function _default_serializer(array $args)
    {
        return Service::createSerializer(
            $args['api'],
            $args['endpoint']
        );
    }

    public static function _default_signature_provider()
    {
        return SignatureProvider::defaultProvider();
    }

    public static function _default_signature_version(array &$args)
    {
        if (isset($args['config']['signature_version'])) {
            return $args['config']['signature_version'];
        }

        $args['__partition_result'] = isset($args['__partition_result'])
            ? isset($args['__partition_result'])
            : call_user_func(PartitionEndpointProvider::defaultProvider(), [
                'service' => $args['service'],
                'region' => $args['region'],
            ]);

        return isset($args['__partition_result']['signatureVersion'])
            ? $args['__partition_result']['signatureVersion']
            : $args['api']->getSignatureVersion();
    }

    public static function _default_signing_name(array &$args)
    {
        if (isset($args['config']['signing_name'])) {
            return $args['config']['signing_name'];
        }

        $args['__partition_result'] = isset($args['__partition_result'])
            ? isset($args['__partition_result'])
            : call_user_func(PartitionEndpointProvider::defaultProvider(), [
                'service' => $args['service'],
                'region' => $args['region'],
            ]);

        if (isset($args['__partition_result']['signingName'])) {
            return $args['__partition_result']['signingName'];
        }

        if ($signingName = $args['api']->getSigningName()) {
            return $signingName;
        }

        return $args['service'];
    }

    public static function _default_signing_region(array &$args)
    {
        if (isset($args['config']['signing_region'])) {
            return $args['config']['signing_region'];
        }

        $args['__partition_result'] = isset($args['__partition_result'])
            ? isset($args['__partition_result'])
            : call_user_func(PartitionEndpointProvider::defaultProvider(), [
                'service' => $args['service'],
                'region' => $args['region'],
            ]);

        return isset($args['__partition_result']['signingRegion'])
            ? $args['__partition_result']['signingRegion']
            : $args['region'];
    }

    public static function _missing_version(array $args)
    {
        $service = isset($args['service']) ? $args['service'] : '';
        $versions = ApiProvider::defaultProvider()->getVersions($service);
        $versions = implode("\n", array_map(function ($v) {
            return "* \"$v\"";
        }, $versions)) ?: '* (none found)';

        return <<<EOT
A "version" configuration value is required. Specifying a version constraint
ensures that your code will not be affected by a breaking change made to the
service. For example, when using Amazon S3, you can lock your API version to
"2006-03-01".

Your build of the SDK has the following version(s) of "{$service}": {$versions}

You may provide "latest" to the "version" configuration value to utilize the
most recent available API version that your client's API provider can find.
Note: Using 'latest' in a production application is not recommended.

A list of available API versions can be found on each client's API documentation
page: http://docs.aws.amazon.com/aws-sdk-php/v3/api/index.html. If you are
unable to load a specific API version, then you may need to update your copy of
the SDK.
EOT;
    }

    public static function _missing_region(array $args)
    {
        $service = isset($args['service']) ? $args['service'] : '';

        return <<<EOT
A "region" configuration value is required for the "{$service}" service
(e.g., "us-west-2"). A list of available public regions and endpoints can be
found at http://docs.aws.amazon.com/general/latest/gr/rande.html.
EOT;
    }

    /**
     * Extracts client options for the endpoint provider to its own array
     *
     * @param array $args
     * @return array
     */
    private static function getEndpointProviderOptions(array $args)
    {
        $options = [];
        $optionKeys = ['sts_regional_endpoints', 's3_us_east_1_regional_endpoint'];
        foreach ($optionKeys as $key) {
            if (isset($args[$key])) {
                $options[$key] = $args[$key];
            }
        }
        return $options;
    }

    /**
     * Validates a region to be used for endpoint construction
     *
     * @param $region
     * @return bool
     */
    private static function isValidRegion($region)
    {
        return is_valid_hostlabel($region);
    }
}
